%{
#include "Types.h"
#include <iostream>
#include "cg.hpp"

extern int yylineno;
extern int yylex();

void yyerror(const char*);
%}


%token STRING ID INT BYTE B BOOL NOT TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC NUM



%right ASSIGN
%left OR
%left AND
%left EQUAL_N
%left RELOP
%left PLUSMINUS
%left MULTDIV
%right NOT
%left LPAREN RPAREN LBRACE RBRACE
%right ELSE


%%

//GOOD
Program : I Statements { $$ = new Program() ;}
Statements : Statement { $$ = new Statements() ;}
Statements : Statements Statement { $$ = new Statements() ;}
Statement : LBRACE M1 Statements M2 RBRACE { $$ = new Statement(nodeTo<Statements>($3)) ;}
Statement : Type ID SC { $$ = new Statement(nodeTo<Type>($1), $2) ;}
Statement : Type ID ASSIGN Exp SC { $$ = new Statement(nodeTo<Type>($1), $2, nodeTo<Exp>($4)) ;}
Statement : ID ASSIGN Exp SC { $$ = new Statement($1, nodeTo<Exp>($3)) ;}
Statement : Call SC { $$ = new Statement(nodeTo<Call>($1)) ;}
Statement : RETURN SC {  $$ = new Statement() ;}


Statement : IF LPAREN Condition RPAREN M1 Statement M2 { $$ = new Statement(false, nodeTo<Exp>($3),nodeTo<Statement>($6)) ;}
Statement : IF LPAREN Condition RPAREN M1 Statement M2 ELSE M4 Statement M2 { $$ = new Statement(false, nodeTo<Exp>($3), nodeTo<Statement>($6), nodeTo<Statement>($10)) ;}
Statement : WHILE LPAREN Condition RPAREN M3 Statement M2 { $$ = new Statement(true, nodeTo<Exp>($3),nodeTo<Statement>($6)) ;}
Statement : BREAK SC { $$ = new Statement($1) ;}
Statement : CONTINUE SC { $$ = new Statement($1) ;}

//GOOD
Call : ID LPAREN Exp RPAREN { $$ = new Call($1, nodeTo<Exp>($3)) ;}
Type : INT {  $$ = new Type("INT") ;}
Type : BYTE { $$ = new Type("BYTE") ;}
Type : BOOL { $$ = new Type("BOOL") ;}
Exp : LPAREN Exp RPAREN { $$ = new Exp($2, "SAME") ;}
Exp : Exp PLUSMINUS Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : Exp MULTDIV Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : ID {  $$ = new Exp($1) ;}
Exp : Call { $$ = new Exp(nodeTo<Call>($1)) ;}
Exp : NUM { $$ = new Exp($1, "INT") ;}
Exp : NUM B { $$ = new Exp($1, "BYTE") ;}
Exp : STRING { $$ = new Exp($1, "STRING") ;}
Exp : TRUE { $$ = new Exp($1, "TRUE") ;}
Exp : FALSE { $$ = new Exp($1, "FALSE") ;}
Exp : NOT Exp { $$ = new Exp($2, "NOT") ;}
Exp : Exp AND Q2 Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : Exp OR Q1 Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : Exp RELOP Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : Exp EQUAL_N Exp { $$ = new Exp( nodeTo<Exp>($1), $2, nodeTo<Exp>($3)) ;}
Exp : LPAREN Type RPAREN Exp { $$ = new Exp(nodeTo<Type>($2), nodeTo<Exp>($4)) ;}

M1 : { ScopesTable::getInstance()->addScope() ;
       CodeBuffer::instance().emit(($-1).m_trueLabel + ":" ;}

M2 : { ScopesTable::getInstance()->removeScope() ;
       ($-3).m_nextLabel = CodeBuffer::instance().freshLabel();
       CodeBuffer::instance().emit("br label %" + ($-3).m_nextLabel;
       CodeBuffer::instance().emit(($-3)->m_falseLabel + ":" ;}

M3 : { ScopesTable::getInstance()->addScope(true) ;}

M4 : { ScopesTable::getInstance()->addScope() ;
       CodeBuffer::instance().emit(($-5).m_falseLabel + ":" ;}

Q1 : { CodeBuffer::instance().emit(($-0).m_falseLabel + ":") ;}
Q2 : { CodeBuffer::instance().emit(($-0).m_trueLabel + ":") ;}

I : { initProgram() ;}

Condition : Exp {CheckConditionIsBool($1);}
%%

void yyerror(const char* msg) {  output::errorSyn(yylineno);
                                  exit(1); }

int main(){
    int semanticCheckResult = yyparse();
    ScopesTable::getInstance()->removeScope();
    return semanticCheckResult;
}
